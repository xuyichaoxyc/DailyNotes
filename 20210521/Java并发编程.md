[TOC]

// Java 并发编程实战

# 知识列表：

+ 并发介绍
  + 并发历史
  + 线程优点
  + 线程风险

================  基础  =====================================

+ 线程安全
  + 什么是线程安全性
  + 原子性
  + 锁
  + 用锁来保护状态
  + 活跃度与性能
+ 共享对象
  + 可见性
  + 发布和溢出
  + 线程封闭
  + 不可变性
  + 安全发布
+ 组合对象
  + 设计线程安全的类
  + 实例限制
  + 委托线程安全
  + 向已有的线程安全类添加功能
  + 同步策略的文档化
+ 构建块
  + 同步容器
  + 并发容器
  + 阻塞队列和生产者-消费者模式
  + 阻塞和可中断的方法
  + synchronizer
  + 为计算结果建立高效、可伸缩的高速缓存

========================  构建并发应用程序  ========================================

+ 任务执行
  + 在线程中执行任务
  + Executor框架
  + 寻找可强化的并行性
+ 取消和关闭
  + 任务取消
  + 停止基于线程的服务
  + 处理反常的线程终止
  + JVM 关闭
+ 应用线程池
  + 任务与执行策略间的隐性耦合
  + 定制线程池的大小
  + 配置 ThreadPoolExecutor
  + 扩展 ThreadPoolExecutor
  + 并行递归算法
+ GUI应用程序
  + GUI程序 单线程化
  + 短期的GUI任务
  + 耗时GUI任务
  + 共享数据模型
  + 其他形式的单线程子系统

=====================  活跃度，性能和测试 =========================================

+ 避免活跃度危险
  + 死锁
  + 避免和诊断死锁
  + 其他的活跃度危险
+ 性能和可伸缩性
  + 性能的思考
  + Amdahl定律
  + 线程引入的开销
  + 减少锁的竞争
  + 示例：比较Map的性能
  + 减少上下文切换的开销
+ 测试并发程序
  + 测试正确性
  + 测试性能
  + 避免测试性能的陷阱
  + 测试方法补遗

====================  高级主题  ===========================================

+ 显示锁
  + Lock 和 ReentrantLock
  + 对性能的考量
  + 公平性
  + 在synchronized 和 ReentrantLock 之间进行选择
  + 读-写锁
+ 构建自定义的同步工具
  + 管理状态依赖性
  + 使用条件队列
  + 显式的Condition对象
  + 剖析Synchronizer
  + AbstractQueuedSynchronizer
  + java.util.concurrent 的 synchronizer 类中的 AQS
+ 原子变量与非阻塞同步机制
  + 锁的劣势
  + 硬件对并发的支持
  + 原子变量类
  + 非阻塞算法
+ Java存储模型
  + 什么是存储模型、存储模型的作用
  + 发布
  + 初始化安全性
+ 同步 Annotation
  + 类 Annotation
  + 域 Annotation 和 方法 Annotation

